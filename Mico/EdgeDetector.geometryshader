#version 430 core
layout(triangles_adjacency) in;
layout(triangle_strip, max_vertices = 4) out;

// constant values for the whole mesh.

uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 ModelMatrix;
uniform vec3 ViewPos;

float edgeLenght = 0.1;

in VertexData
{
    vec3 normal;
	vec2 textCoord;
} vertex[];

out FragmentVertexData
{
    vec3 normal;
	vec3 fragpos;
	vec2 texCoord;
	flat int edgeFlag; 
} VertexOut;
 

void main(){

  vec3 P0 = vec3(ModelMatrix * gl_in[0].gl_Position);
  vec3 P1 = vec3(ModelMatrix * gl_in[2].gl_Position);
  vec3 P2 = vec3(ModelMatrix * gl_in[4].gl_Position);

  vec3 V0 = P1 - P0;
  vec3 V1 = P2 - P0;
  vec3 triangleNormal = cross(V0, V1);
  triangleNormal  =  normalize(triangleNormal);

  // Center of the triangle
  vec3 triangleCentroid = (P0+P1+P2) / 3.0;

  vec3 viewDir = normalize(ViewPos - triangleCentroid);

  // front-facing ?
  if(dot(viewDir,triangleNormal ) <=0)
  {
	// check adjancent triangles
		for(int i = 0; i < 6; i += 2)
		{
		   int iNextTri = (i+2)%6;
		   vec3 V1 = vec3(ModelMatrix * gl_in[i].gl_Position);
           vec3 V2 = vec3(ModelMatrix * gl_in[i+1].gl_Position);
		   vec3 V3 = vec3(ModelMatrix * gl_in[iNextTri].gl_Position);
		   
		   vec3 adjV0 = normalize(V2 - V1);
		   vec3 adjV1 = normalize(V3 - V1);
		   vec3 adjTriangleNormal = cross(adjV0, adjV1);
		   adjTriangleNormal  =  normalize(adjTriangleNormal);

		   vec3 adjTriangleCentroid = (V1+V2+V3) / 3.0;
		   vec3 adjViewDir = normalize( ViewPos - V1 );

		    // back-facing ?
			float dotView = dot(adjViewDir, adjTriangleNormal);
	        if(dotView >= 0)
			{
			  vec3 fragNormal =normalize( mat3(transpose(inverse(ModelMatrix))) * vertex[i].normal);
			  for(int adjv1 = 0; adjv1 < 2; adjv1++)
			  {
				vec3 wsPos = V1 + adjv1 * fragNormal * edgeLenght;
				VertexOut.fragpos = wsPos;
				VertexOut.normal = fragNormal;
				VertexOut.edgeFlag = 1;
				gl_Position = ProjectionMatrix * ViewMatrix * vec4(wsPos,1);
				EmitVertex();
			  }
			 
			  vec3 adjFragNormal = normalize(mat3(transpose(inverse(ModelMatrix))) * vertex[iNextTri].normal);
			  vec4 adjPos = ModelMatrix * gl_in[iNextTri].gl_Position;
			  for(int adjv2 = 0; adjv2 < 2; adjv2++)
			  {
				 vec3 wsPos = adjPos.xyz + adjv2 * adjFragNormal * edgeLenght;
				 VertexOut.fragpos = wsPos;
				 VertexOut.normal = adjFragNormal;
				 VertexOut.edgeFlag = 1;
				 gl_Position = ProjectionMatrix * ViewMatrix * vec4(wsPos,1);
				 EmitVertex();
			  }

			   EndPrimitive();
			}
		}
  }
  

 for (int i = 0; i < 6; i += 2)
 {
        vec4 fragPos      = ModelMatrix * gl_in[i].gl_Position;
        VertexOut.normal  = mat3(transpose(inverse(ModelMatrix))) * vertex[i].normal;
        VertexOut.fragpos = fragPos.xyz;
		VertexOut.edgeFlag = 0;
        gl_Position       = ProjectionMatrix * ViewMatrix * fragPos;
        EmitVertex();
 }
 EndPrimitive();

  


}